filterBy() {

}

search(str) {
  function recur() {

  }

  data.filter(d => {
    // 每次doc有多个field
    // 每个field都要遍历一次

    // 搜索doc的所有值
    // 如果值是Object, Array呢？
    // 递归
    return Object.values().some(value => value === str)
  })

  // 如果指定key
  [key]: value
  [key]: Array<value>
  [key]: Object<key: value>

  // 跳过function
  // 跳过RegExp

  // 可能类型
  // String, Number, Boolean
  // Array, Object, Date


}

data.filter(d => {
  findMatchedValue(entry, needle) {
    // 跳过function
    if (isFunc(entry)) {
      return false
    // 如果是array
    } else if (isArray(entry, needle)) {
      entry.some(e => findMatchedValue(e))
    // 如果是object
    } else if (isPlainObject()) {
      Object.values(entry).some(e => findMatchedValue(e))
    // 其他使用转为string
    } else {
      // 其实上面都是在findPrimitiveValue
      callback(entry)
      return entry.toString().search(new RegExp(needle))
    }

    return findMatchedValue(d, str)
  }

filterBy(data, needle) {
  if (isString(needle)) {
    findMatchedValue(d, needle)
  } else if (isArray(needle)) {

  } else if (isObject(needle)) {
    Object.
  }
}


// 过滤出任意field包含有'hp'的product
filterBy(products, 'hp')

// 过滤出任意field包含有'hp'或'apple'的product
filterBy(products, ['hp', 'apple'])

needle.some(nd => findMatchedValue)

// 过滤出
filterBy(products, {title: 'hp', price: {$lt: 14, $gt: 15}})

title: {$eq: 'hp'}
price: {$lt: 14, $gt: 20},
$match: 'hp'

//

(entry, needle) => {
  for (let [key, value] of Object.entries(needle)) {
    // 如果entry没有指定key, 返回false
    if !(key in entry) return false
    // value是原始值
    if (IsPrimitive(value)) {
      entry[key].search(value)
    } else {
      // $eq, 使用 '==='
      // $lt, $gt, $lte, $gte, 使用比较运算符
    }

    // 满足当前key的所有条件
  }
  // 满足needle对象的所有条件
  return true
}

// 范围过滤


{
  a: 'str',
  b: 1,
  c: ['1', '2'],
  d: {
    l: 'str',
    b: 1,
    n: [2, 4]
  }
}


filterBy(entry, 'hp', deep = true)


filterBy(entry, ['hp', 'apple'], deep = true)


filterBy(entry, { title: 'hp', price: {} }, deep = false)

// 不局限在同一级的key, 只对象内有同名key满足条件
filterBy(entry, { title: 'hp', price: {} }, deep = true)

// 限制必须是同一级key
filterBy(entry, ... deep = true, strict = true)


{
  title: 'hp',
  price: {$gt: 100, $lt: 200},
  // spec prop
  cpu: ['联发科', '高通']
}

matchKey, matchValue
Object.entries(([key, value]) => {
  // 有matchKey, 断言value前先断言key
  // 没有直接断言value

  if (matchKey) {
    // 断言key
    if (!assert) return false
  }
  // 断言value
  assert(value, matchValue)
})

assert(value, matchValue) {
  if (isObject(value)) {
    // 递归
  }
}

// 对于条件对象
[*]: value.match(needle)
[*]: value.matchSome(needle)

[key1] && [key2] && [...] 满足上述断言

// 对于源数据对象

assertEntries(src, dest) {
  // 镜像判断key
  // value = src[key]
  // value单值

  // value是多值

}


title: 'hp',
specProp: {
  price: {}
}

